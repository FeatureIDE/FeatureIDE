/* FeatureIDE - A Framework for Feature-Oriented Software Development
 * Copyright (C) 2005-2017  FeatureIDE team, University of Magdeburg, Germany
 *
 * This file is part of FeatureIDE.
 *
 * FeatureIDE is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * FeatureIDE is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with FeatureIDE.  If not, see <http://www.gnu.org/licenses/>.
 *
 * See http://featureide.cs.ovgu.de/ for further information.
 */
package de.ovgu.featureide.fm.core.explanations;

import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.prop4j.And;
import org.prop4j.Node;
import org.prop4j.NodeWriter;

/**
 * Data class holding the explanation for a circumstance such as a defect in a feature model. Instances of this class are generated by
 * {@link ExplanationCreator}.
 *
 * @param <S> subject
 * @author Timo G&uuml;nther
 * @author Sofia Ananieva
 */
public abstract class Explanation<S> {

	/** The subject to be explained. */
	private final S subject;
	/** The reasons this explanation is composed of mapped to how often the respective reason has been generated. */
	private final Map<Reason<?>, Integer> reasonCounts = new LinkedHashMap<>();
	/** How many explanations have been generated and rolled into one for this explanation. */
	private int explanationCount = 1;

	/**
	 * Constructs a new instance of this class.
	 *
	 * @param subject the subject to be explained
	 */
	protected Explanation(S subject) {
		this.subject = subject;
	}

	/**
	 * Returns the subject of this explanation. That is the object with an attribute to be explained.
	 *
	 * @return the subject of this explanation
	 */
	public S getSubject() {
		return subject;
	}

	/**
	 * Returns how many explanations have been generated and rolled into one for this explanation.
	 *
	 * @return how many explanations have been generated and rolled into one for this explanation
	 */
	public int getExplanationCount() {
		return explanationCount;
	}

	/**
	 * Sets the explanation count.
	 *
	 * @param explanationCount explanation count
	 */
	public void setExplanationCount(int explanationCount) {
		this.explanationCount = explanationCount;
	}

	/**
	 * Returns the reasons this explanation is composed of.
	 *
	 * @return the reasons this explanation is composed of
	 */
	public Set<Reason<?>> getReasons() {
		return reasonCounts.keySet();
	}

	/**
	 * Returns the amount of reasons.
	 *
	 * @return the amount of reasons
	 */
	public int getReasonCount() {
		return reasonCounts.size();
	}

	/**
	 * Returns the reasons this explanation is composed of mapped to how often the respective reason has been generated.
	 *
	 * @return the reasons this explanation is composed of mapped to how often the respective reason has been generated
	 */
	public Map<Reason<?>, Integer> getReasonCounts() {
		return reasonCounts;
	}

	/**
	 * Adds all given reasons to this explanation.
	 *
	 * @param reasons reasons to add
	 */
	public void addReasons(Collection<Reason<?>> reasons) {
		for (final Reason<?> reason : reasons) {
			addReason(reason);
		}
	}

	/**
	 * Adds the given reason to this explanation. Also increments its occurrence count.
	 *
	 * @param reason reason to add
	 */
	public void addReason(Reason<?> reason) {
		addReason(reason, 1);
	}

	/**
	 * Adds the given reason to this explanation. Increases its occurrence count by the given number.
	 *
	 * @param reason reason to add
	 * @param count how often to add the given reason
	 */
	protected void addReason(Reason<?> reason, int count) {
		reason = reason.clone(this);
		final Integer reasonCount = reasonCounts.get(reason);
		reasonCounts.put(reason, (reasonCount == null ? 0 : reasonCount) + count);
	}

	/**
	 * Adds all of the given reasons to this explanation that are not already contained.
	 *
	 * @param reasons reasons to add
	 */
	public void addUniqueReasons(Collection<Reason<?>> reasons) {
		for (final Reason<?> reason : reasons) {
			addUniqueReason(reason);
		}
	}

	/**
	 * Adds the given reason to this explanation if it is not already contained.
	 *
	 * @param reason reason to add
	 */
	public void addUniqueReason(Reason<?> reason) {
		final Integer value = reasonCounts.get(reason);
		if (value == null) {
			reason = reason.clone(this);
			reasonCounts.put(reason, 1);
		}
	}

	/**
	 * Adds all the reasons from the given explanation with their correct occurrence count to this explanation. Also sums up the explanation counts.
	 *
	 * @param explanation explanation to add to this one
	 */
	public void addExplanation(Explanation<? extends S> explanation) {
		for (final Entry<Reason<?>, Integer> reasonCount : explanation.reasonCounts.entrySet()) {
			addReason(reasonCount.getKey(), reasonCount.getValue());
		}
		explanationCount += explanation.explanationCount;
	}

	/**
	 * Sets the reason and explanation counts to the ones in the given explanation. The reasons themselves are not copied, thus maintaining the logical validity
	 * of this explanation.
	 *
	 * @param explanation explanation with reason and explanation counts to copy
	 */
	public void setCounts(Explanation<? extends S> explanation) {
		for (final Entry<Reason<?>, Integer> reasonCount : reasonCounts.entrySet()) {
			reasonCount.setValue(explanation.reasonCounts.get(reasonCount.getKey()));
		}
		explanationCount = explanation.explanationCount;
	}

	/**
	 * Returns an instance of {@link ExplanationWriter} suitable for this explanation.
	 *
	 * @return an instance of {@link ExplanationWriter} suitable for this explanation
	 */
	public abstract ExplanationWriter<? extends Explanation<S>> getWriter();

	/**
	 * Returns this explanation as a propositional formula.
	 *
	 * @return this explanation as a propositional formula
	 */
	public Node toNode() {
		final Node[] clauses = new Node[getReasonCount()];
		int i = 0;
		for (final Reason<?> reason : getReasons()) {
			clauses[i++] = reason.toNode();
		}
		return new And(clauses);
	}

	/**
	 * Returns the formula that is implied logically by this explanation. For example, if this is an explanation for a false-optional feature, the implication
	 * is that the feature's parent implies the feature.
	 *
	 * @return the implication
	 */
	public abstract Node getImplication();

	@Override
	public String toString() {
		final ExplanationWriter<?> writer = getWriter();
		writer.setSymbols(NodeWriter.shortSymbols);
		writer.setWritingReasonCounts(true);
		writer.setWritingLineBreaks(false);
		return writer.getString();
	}
}
