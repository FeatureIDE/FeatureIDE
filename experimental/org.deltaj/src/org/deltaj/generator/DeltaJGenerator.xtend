/*
 * generated by Xtext
 */
package org.deltaj.generator

import com.google.inject.Inject
import java.util.List
import org.deltaj.deltaj.AndOrExpression
import org.deltaj.deltaj.ArithmeticSigned
import org.deltaj.deltaj.Assignment
import org.deltaj.deltaj.BasicType
import org.deltaj.deltaj.BoolConstant
import org.deltaj.deltaj.BooleanNegation
import org.deltaj.deltaj.Cast
import org.deltaj.deltaj.Class
import org.deltaj.deltaj.ClassType
import org.deltaj.deltaj.Comparison
import org.deltaj.deltaj.Expression
import org.deltaj.deltaj.ExpressionStatement
import org.deltaj.deltaj.Field
import org.deltaj.deltaj.FieldSelection
import org.deltaj.deltaj.IfStatement
import org.deltaj.deltaj.IntConstant
import org.deltaj.deltaj.JavaVerbatim
import org.deltaj.deltaj.Message
import org.deltaj.deltaj.Method
import org.deltaj.deltaj.MethodCall
import org.deltaj.deltaj.Minus
import org.deltaj.deltaj.MultiOrDiv
import org.deltaj.deltaj.New
import org.deltaj.deltaj.Null
import org.deltaj.deltaj.Original
import org.deltaj.deltaj.Paren
import org.deltaj.deltaj.Plus
import org.deltaj.deltaj.Product
import org.deltaj.deltaj.ReturnStatement
import org.deltaj.deltaj.Selection
import org.deltaj.deltaj.StringConstant
import org.deltaj.deltaj.This
import org.deltaj.deltaj.Type
import org.deltaj.deltaj.VoidType
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess
import org.eclipse.xtext.generator.IGenerator

import static extension org.eclipse.xtext.xbase.lib.IteratorExtensions.*

class DeltaJGenerator implements IGenerator {
	
	@Inject extension DeltaJGeneratorExtensions generatorExtensions
	
	@Inject DeltaJConstraintsGenerator constraintsGenerator
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		for(product: resource.allContents.toIterable.filter(typeof(Product))) {
			compile(product, fsa)
		}
		constraintsGenerator.doGenerate(resource, fsa)
	}
	
	def compile(Product product, IFileSystemAccess fsa) {
		for (clazz: generatorExtensions.classesToGenerate(product)) {
			compile(product, clazz, fsa)			
		}
	}
	
	def compile(Product product, Class clazz, IFileSystemAccess fsa) {
		fsa.generateFile(generatorExtensions.fileName(product, clazz), 
			compile(product, clazz)
		)
	}
	
	def compile(Product product, Class clazz) '''
		package «generatorExtensions.packageName(product)»;

		public class «clazz.name» «clazz.extendsClause»{
			«FOR f : clazz.fields»
			«f.fieldRep»
			«ENDFOR»
			
			«FOR m : clazz.methods»
			«m.methodRep»
			«ENDFOR»
		}
	'''
	
	def extendsClause(Class clazz) {
		if (clazz.^extends != null)
			'extends ' + clazz.^extends + ' '
		else
			''
	}
	
	def fieldRep(Field field) '''
		«field.type.typeRep» «field.name»;
	'''

	def dispatch typeRep(Type voidType) { "" }

	def dispatch typeRep(VoidType voidType) { "void" }
	
	def dispatch typeRep(BasicType basic) { basic.basic }
	
	def dispatch typeRep(ClassType clazz) { clazz.classref }
	 
	def methodRep(Method method) '''
		public «method.returntype.typeRep» «method.name»(«method.parameterList») {
			«IF method.body != null»
			«method.body.bodyRep»
			«ENDIF»
		}

	'''
	
	def parameterList(Method m) {
		m.params.map(p| p.type.typeRep + ' ' + p.name).join(', ')
	}
	
	def bodyRep(org.deltaj.deltaj.StatementBlock body) '''
		«FOR localvars : body.localvariables»
		«localvars.type.typeRep» «localvars.name»;
		«ENDFOR»
		«FOR statement : body.getStatements»
		«statement.compileStatement»
		«ENDFOR»
	'''

	def dispatch compileStatement(ExpressionStatement expressionStatement) '''
		«expressionStatement.expression.compileExp»;
	'''
	
	def dispatch compileStatement(ReturnStatement returnStmt) '''
		return «IF returnStmt.expression != null»«returnStmt.expression.compileExp»«ENDIF»;
	'''
	
	def dispatch compileStatement(JavaVerbatim javaVerbatim) {
		javaVerbatim.extractJavaVerbatimCode
	}
	
	def dispatch compileStatement(Assignment assignment) '''«assignment.left.compileExp» = «assignment.right.compileExp»;'''

	def dispatch compileStatement(IfStatement ifStatement) '''
		if («ifStatement.expression.compileExp») {
			«ifStatement.thenBlock.bodyRep»
		}«IF ifStatement.elseBlock != null» else {
			«ifStatement.elseBlock.bodyRep»
		}«ENDIF»
	'''

	def dispatch compileExp(Expression expression) '''
		// «expression.eClass.name» generation not yet implemented
	'''
	
	def dispatch compileExp(Plus plus) '''«plus.left.compileExp» + «plus.right.compileExp»'''
	
	def dispatch compileExp(Minus minus) '''«minus.left.compileExp» - «minus.right.compileExp»'''
	
	def dispatch compileExp(MultiOrDiv exp) '''«exp.left.compileExp» «exp.op» «exp.right.compileExp»'''
	
	def dispatch compileExp(Comparison exp) '''«exp.left.compileExp» «exp.op» «exp.right.compileExp»'''
	
	def dispatch compileExp(AndOrExpression exp) '''«exp.left.compileExp» «exp.op» «exp.right.compileExp»'''
	
	def dispatch compileExp(BooleanNegation exp) '''!«exp.expression.compileExp»'''
	
	// we use the parenthesis since --exp in Java has a different meaning
	def dispatch compileExp(ArithmeticSigned exp) '''-(«exp.expression.compileExp»)'''
	
	def dispatch compileExp(This thiz) '''this'''
	
	def dispatch compileExp(Null nul) '''null'''

	def dispatch compileExp(Original original) '''«original.method»(«original.args.compileArgs»)'''
	
	def dispatch compileExp(IntConstant c) '''«c.constant»'''
	
	def dispatch compileExp(StringConstant c) '''"«c.constant»"'''
	
	def dispatch compileExp(BoolConstant c) '''«c.constant»'''
	
	def dispatch compileExp(org.deltaj.deltaj.VariableAccess variable) '''«variable.getVariable.name»'''
	
	def dispatch compileExp(New n) '''new «n.class_»()'''
	
	def dispatch compileExp(Cast cast) '''(«cast.type») «cast.object.compileExp»'''
	
	def dispatch compileExp(Paren paren) '''(«paren.expression.compileExp»)'''
	
	def dispatch compileExp(Selection sel) '''«sel.receiver.compileExp».«sel.message.compileMessage»'''
	
	def dispatch compileMessage(Message message) ''' '''
	
	def dispatch compileMessage(FieldSelection field) '''«field.field»'''
	
	def dispatch compileMessage(MethodCall methodCall) '''«methodCall.method»(«methodCall.args.compileArgs»)'''
	
	def compileArgs(List<Expression> args) {
		args.map(arg | arg.compileExp).join(''', ''')
	}
}
