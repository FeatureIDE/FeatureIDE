<html>
<head>
<title>The Java Language Specification
 The Package java.lang </title>
</head>
<body BGCOLOR=#eeeeff text=#000000 LINK=#0000ff VLINK=#000077 ALINK=#ff0000>
 
<a href="index.html">Contents</a> | <a href="javalang.doc.html">Prev</a> | <a href="javalang.doc2.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<hr><br>
 
<a name="46442"></a>
<center><h1>20.1  The Class  <code>java.lang.Object</code></h1></center>
<a name="46443"></a>
The class <code>Object</code> is the single root of the class hierarchy. All objects, including 
arrays, implement the methods of this class.
<p><pre><a name="14341"></a>public class <code><b>Object</b></code> {
<a name="1546"></a>	public final Class <code><b>getClass</b></code>();
<a name="1551"></a>	public String <code><b>toString</b></code>();
<a name="1556"></a>	public boolean <code><b>equals</b></code>(Object obj);
<a name="1560"></a>	public int <code><b>hashCode</b></code>();
<a name="1570"></a>	protected Object <code><b>clone</b></code>()
<a name="30882"></a>		throws CloneNotSupportedException;
<a name="31617"></a>	public final void <code><b>wait</b></code>()<br>
		throws IllegalMonitorStateException,<br>
			InterruptedException;
<a name="31619"></a>	public final void <code><b>wait</b></code>(long millis)<br>
		throws IllegalMonitorStateException,<br>
			InterruptedException;
<a name="1573"></a>	public final void <code><b>wait</b></code>(long millis, int nanos)<br>
		throws IllegalMonitorStateException,
<a name="28224"></a>			InterruptedException;
<a name="1574"></a>	public final void <code><b>notify</b></code>()
<a name="28242"></a>		throws IllegalMonitorStateException;
<a name="1575"></a>	public final void <code><b>notifyAll</b></code>()
<a name="28235"></a>		throws IllegalMonitorStateException;
<a name="27958"></a>	protected void <code><b>finalize</b></code>()<br>
		throws Throwable;
<a name="1581"></a>}
</pre><a name="13783"></a>
<p><font size=+1><strong>20.1.1   </strong> <code>public final Class <code><b>getClass</b></code>()</code></font>
<p>
<a name="14552"></a>
This method returns a reference to the unique object of type <code>Class</code> <a href="javalang.doc2.html#14342">(&#167;20.3)</a> that 
represents the class of this object. That <code>Class</code> object is the object that is locked by 
<code>static synchronized </code>methods of the represented class.
<p><a name="1152"></a>
<p><font size=+1><strong>20.1.2   </strong> <code>public String <code><b>toString</b></code>()</code></font>
<p>
<a name="1153"></a>
The general contract of <code>toString</code> is that it returns a string that "textually represents"
this object. The idea is to provide a concise but informative representation 
that will be useful to a person reading it.
<p><a name="30954"></a>
The <code>toString</code> method defined by class <code>Object</code> returns a string consisting of the name of the class of which the object is an instance, a commercial at character <code>'@'</code>, and the unsigned hexadecimal representation of the hashcode of the object. In other words, this method returns a string equal to the value of:<p>
<pre><a name="30955"></a>getClass().getName() + <code>'</code>@<code>'</code> + Integer.toHexString(hashCode())
</pre><a name="30965"></a>
Overridden by <code>Class</code> <a href="javalang.doc2.html#14342">(&#167;20.3)</a>, <code>Boolean</code> <a href="javalang.doc3.html#14344">(&#167;20.4)</a>, <code>Character</code> <a href="javalang.doc4.html#14345">(&#167;20.5)</a>, <code>Integer</code> <a href="javalang.doc6.html#14348">(&#167;20.7)</a>, <code>Long</code> <a href="javalang.doc7.html#46750">(&#167;20.8)</a>, <code>Float</code> <a href="javalang.doc8.html#14394">(&#167;20.9)</a>, <code>Double</code> <a href="javalang.doc9.html#14390">(&#167;20.10)</a>, <code>String</code> <a href="javalang.doc11.html#14460">(&#167;20.12)</a>, <code>StringBuffer</code> <a href="javalang.doc12.html#14461">(&#167;20.13)</a>, <code>Thread</code> <a href="javalang.doc18.html#2658">(&#167;20.20)</a>, <code>ThreadGroup</code> <a href="javalang.doc19.html#14469">(&#167;20.21)</a>, <code>Throwable</code> <a href="javalang.doc20.html#3276">(&#167;20.22.4)</a>, and <code>Bitset</code> <a href="javautil.doc1.html#7404">(&#167;21.2)</a>.<p>
<a name="14865"></a>
<p><font size=+1><strong>20.1.3   </strong> <code>public boolean <code><b>equals</b></code>(Object obj)</code></font>
<p>
<a name="14921"></a>
This method indicates whether some other object is "equal to" this one.
<p><a name="14922"></a>
The general contract of <code>equals</code> is that it implements an equivalence relation:<p>
<ul><a name="14893"></a>
<li>It is <i>reflexive</i>: for any reference value <code>x</code>, <code>x.equals(x)</code> should return <code>true</code>.
<a name="14894"></a>
<li>It is <i>symmetric</i>: for any reference values <code>x</code> and <code>y</code>, <code>x.equals(y)</code> should return <code>true</code> if and only if <code>y.equals(x)</code> returns <code>true</code>.
<a name="14895"></a>
<li>It is <i>transitive</i>: for any reference values <code>x</code>, <code>y</code>, and <code>z</code>, if <code>x.equals(y)</code> returns <code>true</code> and <code>y.equals(z)</code> returns <code>true</code>, then <code>x.equals(z)</code> should return <code>true</code>.
<a name="14904"></a>
<li>It is <i>consistent</i>: for any reference values <code>x</code> and <code>y</code>, multiple invocations of <code>x.equals(y)</code> consistently return <code>true</code> or consistently return <code>false</code>, provided no information used by <code>x</code> and <code>y</code> in <code>equals</code> comparisons is modified.
<a name="14908"></a>
<li>For any non-null reference value <code>x</code>, <code>x.equals(null)</code> should return <code>false</code>.
</ul><a name="44256"></a>
The <code>equals</code> method defined by class <code>Object</code> implements the most discriminating possible equivalence relation on objects; that is, for any reference values <code>x</code> and <code>y</code>, <code>((Object)x).equals(y)</code> returns <code>true</code> if and only if <code>x</code> and <code>y</code> refer to the same object.<p>
<a name="44266"></a>
Overridden by <code>Boolean</code> <a href="javalang.doc3.html#14344">(&#167;20.4)</a>, <code>Character</code> <a href="javalang.doc4.html#14345">(&#167;20.5)</a>, <code>Integer</code> <a href="javalang.doc6.html#14348">(&#167;20.7)</a>, <code>Long</code> <a href="javalang.doc7.html#46750">(&#167;20.8)</a>, <code>Float</code> <a href="javalang.doc8.html#14394">(&#167;20.9)</a>, <code>Double</code> <a href="javalang.doc9.html#14390">(&#167;20.10)</a>, <code>String</code> <a href="javalang.doc11.html#14460">(&#167;20.12)</a>, and <code>Bitset</code> <a href="javautil.doc1.html#7404">(&#167;21.2)</a>.<p>
<a name="13784"></a>
<p><font size=+1><strong>20.1.4   </strong> <code>public int <code><b>hashCode</b></code>()</code></font>
<p>
<a name="34698"></a>
This method is supported principally for the benefit of hash tables such as those 
provided by the Java library class <code>java.util.Hashtable</code> <a href="javautil.doc4.html#23193">(&#167;21.5)</a>.
<p><a name="34702"></a>
The general contract of <code>hashCode</code> is as follows:<p>
<ul><a name="14763"></a>
<li>Whenever it is invoked on the same object more than once during an execution of a Java application, <code>hashCode</code> must consistently return the same integer. &#32;The integer may be positive, negative, or zero. This integer does not, however, have to remain consistent from one Java application to another, or from one execution of an application to another execution of the same application.
<a name="14778"></a>
<li>If two objects are equal according to the <code>equals</code> method <a href="javalang.doc1.html#14865">(&#167;20.1.3)</a>, then calling the <code>hashCode</code> method on each of the two objects must produce the same integer result.
<a name="14827"></a>
<li>It is <i>not</i> required that if two objects are unequal according to the <code>equals</code> method <a href="javalang.doc1.html#14865">(&#167;20.1.3)</a>, then calling the <code>hashCode</code> method on each of the two objects must produce distinct integer results. However, the programmer should be aware that producing distinct integer results for unequal objects may improve the performance of hashtables.
</ul><a name="14811"></a>
As much as is reasonably practical, the <code>hashCode</code> method defined by class <code>Object</code> does return distinct integers for distinct objects. (This is typically implemented by converting the internal address of the object into an integer, but this implementation technique is not required by the Java language.)<p>
<a name="8495"></a>
Overridden by <code>Boolean</code> <a href="javalang.doc3.html#14344">(&#167;20.4)</a>, <code>Character</code> <a href="javalang.doc4.html#14345">(&#167;20.5)</a>, <code>Integer</code> <a href="javalang.doc6.html#14348">(&#167;20.7)</a>, <code>Long</code> <a href="javalang.doc7.html#46750">(&#167;20.8)</a>, <code>Float</code> <a href="javalang.doc8.html#14394">(&#167;20.9)</a>, <code>Double</code> <a href="javalang.doc9.html#14390">(&#167;20.10)</a>, <code>String</code> <a href="javalang.doc11.html#14460">(&#167;20.12)</a>, and <code>Bitset</code> <a href="javautil.doc1.html#7404">(&#167;21.2)</a>.<p>
<a name="14934"></a>
<p><font size=+1><strong>20.1.5   </strong> <code>protected Object <code><b>clone</b></code>()<br>throws CloneNotSupportedException</code></font>
<p>
<a name="28429"></a>
The general contract of clone is that it creates and returns a copy of this object. 
The precise meaning of "copy" may depend on the class of the object. The general 
intent is that, for any object <code>x</code>, the expression:
<p><pre><a name="28430"></a>x.clone() != x
</pre><a name="28437"></a>
will be <code>true</code>, and that the expression:
<p><pre><a name="28454"></a>x.clone.getClass() == x.getClass()
</pre><a name="28455"></a>
will be <code>true</code>, but these are not absolute requirements. While it is typically the case 
that:
<p><pre><a name="28448"></a>x.clone.equals(x)
</pre><a name="28449"></a>
will be <code>true</code>, this is not an absolute requirement. Copying an object will typically 
entail creating a new instance of its class, but it also may require copying of internal
data structures as well.
<p><a name="28465"></a>
The method <code>clone</code> for class <code>Object</code> performs a specific cloning operation. First, if the class of this object does not implement the interface <code>Cloneable</code>, then a <code>CloneNotSupportedException</code> is thrown. Note that all arrays are considered to implement the interface <code>Cloneable</code>. Otherwise, this method creates a new instance of the class of this object and initializes all its fields with exactly the contents of the corresponding fields of this object, as if by assignment; the contents of the fields are not themselves cloned. Thus, this method performs a "shallow copy" of this object, not a "deep copy" operation.<p>
<a name="28483"></a>
The class <code>Object</code> does <i>not</i> itself implement the interface <code>Cloneable</code>, so calling the <code>clone</code> method on an object whose class is <code>Object</code> will result in throwing an exception at run time. The <code>clone</code> method is implemented by the class <code>Object</code> as a convenient, general utility for subclasses that implement the interface <code>Cloneable</code>, &#32;possibly also overriding the <code>clone</code> method, in which case the overriding definition can refer to this utility definition by the call:<p>
<pre><a name="28499"></a>super.clone()
</pre><a name="33394"></a>
<p><font size=+1><strong>20.1.6   </strong> <code>public final void <code><b>wait</b></code>()<br>throws IllegalMonitorStateException,  &#32; &#32; &#32;InterruptedException</code></font>
<p>
<a name="33395"></a>
This method causes the current thread to wait until some other thread invokes the 
<code>notify</code> method <a href="javalang.doc1.html#13789">(&#167;20.1.9)</a> or the <code>notifyAll</code> method <a href="javalang.doc1.html#13790">(&#167;20.1.10)</a> for this object.
<p><a name="28160"></a>
In other words, this method behaves exactly as if it simply performs the call <code>wait(0)</code> <a href="javalang.doc1.html#14926">(&#167;20.1.7)</a>.<p>
<a name="14926"></a>
<p><font size=+1><strong>20.1.7   </strong> <code>public final void <code><b>wait</b></code>(long millis)<br>	throws IllegalMonitorStateException,  &#32; &#32; &#32;InterruptedException</code></font>
<p>
<a name="28260"></a>
This method causes the current thread to wait until either some other thread 
invokes the <code>notify</code> method <a href="javalang.doc1.html#13789">(&#167;20.1.9)</a> or the <code>notifyAll</code> method <a href="javalang.doc1.html#13790">(&#167;20.1.10)</a> for 
this object, or a certain amount of real time has elapsed.
<p><a name="28267"></a>
This method may be called only when the current thread is already synchronized on this object. If the current thread does not own the lock on this object, an <code>IllegalMonitorStateException</code> is thrown.<p>
<a name="28211"></a>
This method causes the current thread (call it <i>T</i>) to place itself in the wait set <a href="17.doc.html#28471">(&#167;17.14)</a> for this object and then to relinquish any and all synchronization claims on this object. Thread <i>T</i> becomes disabled for thread scheduling purposes and lies dormant until one of four things happens:<p>
<ul><a name="28119"></a>
<li>Some other thread invokes the <code>notify</code> method for this object and thread <i>T</i> happens to be arbitrarily chosen as the thread to be awakened.
<a name="28120"></a>
<li>Some other thread invokes the <code>notifyAll</code> method for this object.
<a name="29107"></a>
<li>Some other thread interrupts <a href="javalang.doc18.html#29179">(&#167;20.20.31)</a> thread <i>T</i>.
<a name="28130"></a>
<li>The specified amount of real time has elapsed, more or less. The amount of real time, measured in milliseconds, is given by <code>millis</code>. If <code>millis</code> is zero, however, then real time is not taken into consideration and the thread simply waits until notified.
</ul><a name="28148"></a>
The thread <i>T</i> is then removed from the wait set for this object and re-enabled for 
thread scheduling. It then competes in the usual manner with other threads for the 
right to synchronize on the object; once it has gained control of the object, all its 
synchronization claims on the object are restored to the status quo ante-that is, to 
the situation as of the time that the <code>wait</code> method was invoked. Thread <i>T</i> then 
returns from the invocation of the <code>wait</code> method. Thus, on return from the <code>wait</code> 
method, the synchronization state of the object and of thread <i>T</i> is exactly as it was 
when the <code>wait</code> method was invoked.
<p><a name="29110"></a>
If the current thread is interrupted <a href="javalang.doc18.html#29179">(&#167;20.20.31)</a> by another thread while it is waiting, then an <code>InterruptedException</code> is thrown. This exception is not thrown until the lock status of this object has been restored as described above.<p>
<a name="28155"></a>
Note that the <code>wait</code> method, as it places the current thread into the wait set for this object, unlocks only this object; any other objects on which the current thread may be synchronized remain locked while the thread waits.<p>
<a name="32520"></a>
<p><font size=+1><strong>20.1.8   </strong> <code>public final void <code><b>wait</b></code>(long millis, int nanos)<br>	throws IllegalMonitorStateException,  &#32; &#32; &#32;InterruptedException</code></font>
<p>
<a name="32521"></a>
This method causes the current thread to wait until either some other thread 
invokes the <code>notify</code> method <a href="javalang.doc1.html#13789">(&#167;20.1.9)</a> or the <code>notifyAll</code> method <a href="javalang.doc1.html#13790">(&#167;20.1.10)</a> for 
this object, or some other thread interrupts the current thread, or a certain amount 
of real time has elapsed.
<p><a name="28106"></a>
The amount of real time, measured in nanoseconds, is given by:<p>
<pre><a name="28107"></a><code>1000000*millis+nanos
</code></pre><a name="28178"></a>
In all other respects, this method does the same thing as the method <code>wait</code> of one 
argument <a href="javalang.doc1.html#14926">(&#167;20.1.7)</a>. In particular, <code>wait(0,</code> <code>0)</code> means the same thing as <code>wait(0)</code>.
<p><a name="13789"></a>
<p><font size=+1><strong>20.1.9   </strong> <code>public final void <code><b>notify</b></code>()<br>throws IllegalMonitorStateException</code></font>
<p>
<a name="27974"></a>
If any threads are waiting <a href="javalang.doc1.html#14926">(&#167;20.1.7)</a> on this object, one of them is chosen to be 
awakened. The choice is arbitrary and at the discretion of the implementation.
<p><a name="28277"></a>
The <code>notify</code> method may be called only when the current thread is already synchronized on this object. If the current thread does not own the lock on this object, an <code>IllegalMonitorStateException</code> is thrown.<p>
<a name="28289"></a>
The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.<p>
<a name="13790"></a>
<p><font size=+1><strong>20.1.10   </strong> <code>public final void <code><b>notifyAll</b></code>()<br>throws IllegalMonitorStateException</code></font>
<p>
<a name="28304"></a>
All the threads waiting <a href="javalang.doc1.html#14926">(&#167;20.1.7)</a> on this object are awakened.
<p><a name="28317"></a>
The <code>notifyAll</code> method may be called only when the current thread is already synchronized on this object. If the current thread does not own the lock on this object, an <code>IllegalMonitorStateException</code> is thrown.<p>
<a name="28306"></a>
The awakened threads will not be able to proceed until the current thread relinquishes the lock on this object. The awakened threads will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened threads enjoy no reliable privilege or disadvantage in being the next thread to lock this object.<p>
<a name="23198"></a>
<p><font size=+1><strong>20.1.11   </strong> <code>protected void <code><b>finalize</b></code>() throws Throwable</code></font>
<p>
<a name="28342"></a>
The general contract of <code>finalize</code> is that it is invoked if and when the Java Virtual 
Machine has determined that there is no longer any means by which this object 
can be accessed by any thread that has not yet died <a href="12.doc.html#48744">(&#167;12.7)</a>, except as a result of an 
action taken by the finalization of some other object or class which is ready to be 
finalized. The <code>finalize</code> method may take any action, including making this 
object available again to other threads; the usual purpose of <code>finalize</code>, however, 
is to perform cleanup actions before the object is irrevocably discarded. For example,
the <code>finalize</code> method for an object that represents an input/output connection 
might perform explicit I/O transactions to break the connection before the object 
is permanently discarded.
<p><a name="28363"></a>
The <code>finalize</code> method of class <code>Object</code> performs no special action; it simply returns normally. Subclasses of <code>Object</code> may override this definition.<p>
<a name="28343"></a>
Java does not guarantee which thread will invoke the <code>finalize</code> method for any given object. It is guaranteed, however, that the thread that invokes <code>finalize</code> will not be holding any user-visible synchronization locks when <code>finalize</code> is invoked. If an uncaught exception is thrown by the <code>finalize</code> method, the exception is ignored and finalization of that object terminates.<p>
<a name="28344"></a>
After the <code>finalize</code> method has been invoked for an object, no further action is taken until the Java Virtual Machine has again determined that there is no longer any means by which this object can be accessed by any thread that has not yet died, including possible actions by other objects or classes which are ready to be finalized, at which point the object may be discarded.<p>
<a name="32361"></a>
The <code>finalize</code> method is never invoked more than once by a Java Virtual Machine for any given object.<p>
<a name="31348"></a>
<h1>20.2  The Interface  <code>java.lang.Cloneable</code></h1>
<a name="31349"></a>
The <code>Cloneable</code> interface should be implemented by any class that is intended to 
support or override the method <code>clone</code> <a href="javalang.doc1.html#14934">(&#167;20.1.5)</a>.
<p><pre><a name="31350"></a>public interface <code><b>Cloneable</b></code> { }
<a name="31383"></a>
</pre><a name="34773"></a>
The interface <code>Cloneable</code> declares no methods.<img src="javalang.doc.anc47.gif">
<p>

<hr>
<!-- This inserts footnotes--><p>
<a href="index.html">Contents</a> | <a href="javalang.doc.html">Prev</a> | <a href="javalang.doc2.html">Next</a> | <a href="j.index.doc1.html">Index</a>
<p>
<font size=-1>Java Language Specification (HTML generated by Suzette Pelouch on February 24, 1998)<br>
<i><a href="jcopyright.doc.html">Copyright &#169 1996 Sun Microsystems, Inc.</a>
All rights reserved</i>
<br>
Please send any comments or corrections to <a href="mailto:doug.kramer@sun.com">doug.kramer@sun.com</a>
</font>
</body></html>